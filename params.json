{"name":"Knockout-key.subkey","tagline":"Add support to Knockout for key.subkey bindings for attr, css, style, event, and more.","body":"### **Key.Subkey Binding** plugin for [Knockout](http://knockoutjs.com/)\r\n\r\nThis plugin enables you to use a new syntax for Knockout’s built-in bindings `attr`, `css`, `sytle`, and `event`. This new syntax combines the name of the binding and the item you want to bind without having to use a sub-object.\r\n\r\n#### Syntax examples\r\n\r\n```javascript\r\nattr.href: url, attr.title: details\r\nattr.data-something: someValue\r\n\r\ncss.profitWarning: currentProfit() < 0, css.majorHighlight: isSevere\r\ncss.my-class: someValue\r\n\r\nstyle.color: currentProfit() < 0 ? 'red' : 'black'\r\n\r\nevent.mouseover: enableDetails, event.mouseout: disableDetails\r\n```\r\n\r\n#### Advantages over the built-in syntax\r\n\r\nThis syntax is more concise because it eliminates the need for extra curly braces and quotes. For example, compare the following:\r\n\r\n```javascript\r\nattr: { 'data-something': someValue }\r\n\r\nattr.data-something: someValue\r\n```\r\n\r\nThis syntax more clearly expresses that multiple bindings of the same type are separate. For example, compare:\r\n\r\n```javascript\r\nattr: { href: url, title: details }\r\n\r\nattr.href: url, attr.title: details\r\n```\r\n\r\nWhen combined with [Knockout-Freedom](https://github.com/mbest/knockout-freedom), this syntax ensures that each of multiple attributes (etc.) is only updated when its own dependencies change. This is especially important when an update has side effects or involves some significant amount of work. For example, in the first case below, an update to `myId` will update both bindings and cause the `iframe` to reload (in some browsers); but in the second case, only an update to `baseUrl` will cause it to reload:\r\n\r\n```html\r\n<iframe data-bind=\"attr: { src: baseUrl, id: myId }\"></iframe>\r\n\r\n<iframe data-bind=\"attr.src: baseUrl, attr.id: myId\"></iframe>\r\n```\r\n\r\n#### How this plugin works\r\n\r\nTo use this plugin, simply include `knockout-key.subkey.js` in your page after you’ve included Knockout. You can then start using the new syntax in your data bindings. If you have existing code that uses the original syntax, you do *not* have to change it, since this plugin doesn’t disable the old syntax.\r\n\r\nEach time you use a new *key.subkey* binding in your view, this plugin dynamically creates a binding handler for it. It does this by wrapping two Knockout functions, `ko.bindingProvider.instance.getBindings` (used for most bindings) and `ko.applyBindingsToNode` (used for bindings within string-based templates such as jQuery-tmpl).\r\n\r\n#### Using this syntax for custom bindings\r\n\r\nIf your binding follows the same pattern as the supported built-in bindings, it will work automatically with the new syntax. Here’s an example custom binding handler:\r\n\r\n```javascript\r\nko.bindingHandlers.dataAttr = {\r\n    update: function(element, valueAccessor) {\r\n        var value = ko.utils.unwrapObservable(valueAccessor()) || {};\r\n        for (var subKey in value) {\r\n            var dataValue = ko.utils.unwrapObservable(value[subKey]);\r\n            if (!dataValue && dataValue !== 0)\r\n                element.removeAttribute(\"data-\" + subKey);\r\n            else\r\n                element.setAttribute(\"data-\" + subKey, dataValue.toString());\r\n        }\r\n    }\r\n};\r\n```\r\n\r\nThe binding could then be used like this:\r\n\r\n```html\r\n<div data-bind=\"dataAttr.one: 'one', dataAttr.two: 'two'\"></div>\r\n```\r\n\r\nAlternatively, if your custom binding is only meant to work with the new syntax, you can use the new `makeSubkeyHandler` function to define how to handle the binding:\r\n\r\n```javascript\r\nko.bindingHandlers.dataAttr = {\r\n    makeSubkeyHandler: function(baseKey, subKey, combinedKey) {\r\n        return {\r\n            update: function(element, valueAccessor) {\r\n                var dataValue = ko.utils.unwrapObservable(valueAccessor());\r\n                if (!dataValue && dataValue !== 0)\r\n                    element.removeAttribute(\"data-\" + subKey);\r\n                else\r\n                    element.setAttribute(\"data-\" + subKey, dataValue.toString());\r\n            }\r\n        };\r\n    }\r\n};\r\n```\r\n\r\n#### Interfaces\r\n\r\nThis plugin exports `ko.keySubkeyBinding.makeHandler`, which can be used to manually generate a *key.subkey* binding handler. It both saves the handler in `ko.bindingHandlers` as *key.subkey* and returns the handler object. If the specified binding handler was already created before, `makeHandler` will create a new one, overwriting the old one. You can use this, for example, to create an alias for a binding:\r\n\r\n```javascript\r\nko.bindingHandlers.id = ko.keySubkeyBinding.makeHandler('attr.id');\r\n```\r\n\r\nThis plugin also exports `ko.getBindingHandler` with similar functionality to `makeHandler`. But `getBindingHandler` will simply return, rather than re-create, an existing binding handler.\r\n\r\nAs described in the section about custom bindings, when trying to dynamically create an `x.y` (for example) binding handler, this plugin will call `ko.bindingHandlers.x.makeSubkeyHandler('x', 'y', 'x.y')` if the function exists, which should return a binding handler object for that sub-key (with `init` and/or `update` functions).\r\n\r\n#### License and Contact\r\n\r\n**License:** MIT (http://www.opensource.org/licenses/mit-license.php)\r\n\r\nMichael Best<br>\r\nhttps://github.com/mbest<br>\r\nmbest@dasya.com\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}